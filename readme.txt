=============================== Group X Compiler ===============================

The project uses C++ 17 with GNU extensions (-std=gnu++17). Source code and
header files are in the `src/` directory, and tests are in the `tests/`
directory (Test Engineer feel free to set this up however you want). The entry
point is main.cpp in the top level directory, and there are a few make targets
you can use to build in debug/release mode or to run tests:

make all: builds debug and release
make debug: builds debug (-Og) which has some flags enabled that make debugging
    easier
make release: builds release with flags for speed optimizations
make clean: cleans up artifacts generated by the build process

make test_debug: builds test binary in debug mode and runs it, then deletes the
    binary
make test_release: builds test binary in release mode and runs it, then deletes
    the binary
make test_all: builds debug and release test binaries, runs them, and cleans
    them up

==================================== Tests ====================================

Tests are in the `tests/` directory. The entry point for the test binary is
`tests/main.cpp`. I set this up so that individual unit tests can be written
to test different parts of the app separately. The functions to run tests are
declared `extern` in main.cpp, and are added to an array of function pointers
so that the tests can all be run in sequence. If a single test fails, then the
entire suite fails. C and C++ have assert and static assert macros that allow
us to test for conditions at runtime and compile time respectively. I wrote a
stub test using assert in `tests/stub.cpp`. This is just a start, the Test
Engineer is free to extend this, discard this, or whatever.

================================== Dev Setup ==================================

You may want to add the following line to your .vimrc:

    au BufReadPost *.ypp set syntax=yacc

This tells Vim to use yacc syntax highlighting for .ypp files.

==================================== TODOs ====================================

1. We are still finishing the parser. We still need include/imports, boolean
    expressions, static array types, for loops, string literals, char literals, and
    better error messages. We should also fix up the grammar so that it resembles 
    our LRM more closely.

2. We may need a way to parse command line args and options. unistd.h has some 
    utils for this but the C++ standard library might have better ones. We should
    have a command line argument to specify an optional AST graph for now and binary
    output later.

3. Typechecker - I will start work on this when the parser is mostly done

4. Three address code

5. LLVM backend? Or maybe just target linux on x86
