%define api.pure full

%code requires {
#include <stdio.h>
#include "ast.h"
#include "symtable.h"
#include "parser.h"
#include "parsedecls.h"

typedef void* yyscan_t;
}

%param { yyscan_t scanner }
%parse-param { ParserState * state }

%code provides {
extern void yyerror (yyscan_t scanner, ParserState * state, char const *format, ...);
}

%code {
int yylex(YYSTYPE * yylvalp, yyscan_t scanner);
}

%union {
    int int_val;
    float float_val;
    char * c_str;

    ASTNode * ast;
    ProgramSource * program_source;
    Statement * statement;
    StatementList * statement_list;
    Expr * expr;
    ExprList * expr_list;
    NumLiteral * num_literal;
    IntLiteral * int_literal;
    FloatLiteral * float_literal;
    BoolLiteral * bool_literal;
    CharLiteral * char_literal;
    StringLiteral * str_literal;
    Ident * ident;
    MathExpr * math_expr;
    BoolExpr * bool_expr;
    LogicalExpr * logical_expr;
    Typename * type_name;
    PtrTypename * ptr_type_name;
    MutTypename * mut_type_name;
    TupleTypename * tuple_type_name;
    ParensTypename * parens_type_name;
    TypenameList * type_list;
    VarDeclList * var_decl_list;
    FuncTypename * func_type_name;
    StaticArrayTypename * static_arr_type_name;
    TypeAlias * type_alias;
    TypeDecl * type_decl;
    StructDecl * struct_decl;
    VarDecl * var_decl;
    VarDeclInit * var_decl_init;
    ArrayLiteral * array_literal;
    AddrOf * addr_of;
    Deref * deref;
    CastExpr * cast_expr;
    TupleExpr * tuple_expr;
    FunctionCallExpr * function_call_expr;
    FunctionCallStmt * function_call_stmt;
    ParamsList * params_list;
    FuncDecl * func_decl;
    ReturnStatement * return_statement;
    IfStmt * if_statement;
    IfElseStmt * if_else_statement;
    WhileStmt * while_statement;
    ForStmt * for_statement;
    TypeIdent * type_ident;
    Assignment * assignment;
    PreExpr * pre_expr;
}

%token FUNC_TYPE_OP

%right '='
%right TYPE_ALIAS_KW STRUCT_KW RETURN_KW
%precedence FUNC_PREC
%nonassoc '(' ')'
%nonassoc '[' ']'
%right BOOL_AND BOOL_OR AND_KW OR_KW
%nonassoc EQU NEQ
%nonassoc GTR LES GEQ LEQ
%nonassoc IN_KW NOT_IN_KW
%right '+' '-'
%right '/' '%'
%nonassoc MUL_OP
%nonassoc CAST_KW
%right MUT
%left '*'
%right '&'
%right IF_KW WHILE_KW FOR_KW
%right ELSE_KW
%right '!' NOT_KW
%right INC DEC

%nonassoc CALL_PREC

%nonassoc <ident> IDENT DECLARED_VAR DECLARED_FUNC
%nonassoc <type_ident> DECLARED_TYPE
%nonassoc <int_literal> INT
%nonassoc <float_literal> FLOAT
%nonassoc <bool_literal> BOOL
%nonassoc <str_literal> STR
%nonassoc <char_literal> CHAR

%type <program_source> program
%type <statement> statement
%type <statement_list> statement_list
%type <num_literal> num
%type <expr> expr
%type <expr_list> expr_list args_list
%type <math_expr> math_expr
%type <bool_expr> bool_expr
%type <logical_expr> logical_expr
%type <type_name> type_name
%type <type_ident> simple_type_name
%type <ptr_type_name> ptr_type_name
%type <mut_type_name> mut_type_name
%type <tuple_type_name> tuple_type_name
%type <parens_type_name> parens_type_name
%type <func_type_name> func_type_name
%type <static_arr_type_name> static_arr_type_name
%type <type_list> type_list
%type <var_decl_list> var_decl_list
%type <struct_decl> struct_decl
%type <type_alias> type_alias
%type <type_decl> type_decl
%type <var_decl> var_decl
%type <var_decl_init> var_decl_init
%type <array_literal> array_literal
%type <addr_of> addr_of_expr
%type <deref> deref_expr
%type <cast_expr> cast_expr
%type <tuple_expr> tuple_expr
%type <function_call_expr> function_call_expr
%type <function_call_stmt> function_call_stmt
%type <params_list> params_list
%type <func_decl> func_decl
%type <return_statement> return_statement
%type <if_statement> if_statement
%type <if_else_statement> if_else_statement
%type <while_statement> while_statement
%type <for_statement> for_statement
%type <assignment> assignment
%type <pre_expr> pre_expr

%%

top_level : program {state->top = $1; YYACCEPT;}
          ;

program : program type_decl ';' {$1->add_node($2); $$ = $1;}
        | program var_decl_init ';' {$1->add_node($2); $$ = $1;}
        | program var_decl ';' {$1->add_node($2); $$ = $1;}
        | program func_decl ';' {$1->add_node($2); $$ = $1;}
        | /* empty */ {$$ = new ProgramSource({});}
        ;

statement : type_decl {$$ = $1;}
          | var_decl {$$ = $1;}
          | var_decl_init {$$ = $1;}
          | function_call_stmt {$$ = $1;}
          | return_statement {$$ = $1;}
          | if_statement {$$ = $1;}
          | if_else_statement {$$ = $1;}
          | while_statement {$$ = $1;}
          | for_statement {$$ = $1;}
          | assignment {$$ = $1;}
          ;

statement_list : statement ';' {$$ = new StatementList({$1});}
               | statement_list statement ';' {$1->push_statement($2); $$ = $1;}
               ;

expr : '(' expr ')' {$$ = new ParensExpr($2);}
     | math_expr {$$ = $1;}
     | bool_expr {$$ = $1;}
     | logical_expr {$$ = $1;}
     | addr_of_expr {$$ = $1;}
     | deref_expr {$$ = $1;}
     | cast_expr {$$ = $1;}
     | tuple_expr {$$ = $1;}
     | array_literal {$$ = $1;}
     | function_call_expr %prec CALL_PREC {$$ = (Expr *) $1;}
     | '!' expr {$$ = new BangExpr($2);}
     | NOT_KW expr {$$ = new NotExpr($2);}
     | pre_expr {$$ = $1;}
     | STR {$$ = $1;}
     | BOOL {$$ = $1;}
     | CHAR {$$ = $1;}
     | num {$$ = $1;}
     | DECLARED_VAR {$$ = $1;}
     ;

expr_list : expr {$$ = new ExprList({$1});}
          | expr_list ',' expr {$1->push_expr($3); $$ = $1;}
          ;

math_expr : expr '+' expr {$$ = new MathExpr('+', $1, $3);}
          | expr '-' expr {$$ = new MathExpr('-', $1, $3);}
          | expr '*' expr %prec MUL_OP {$$ = new MathExpr('*', $1, $3);}
          | expr '%' expr %prec MUL_OP {$$ = new MathExpr('%', $1, $3);}
          | expr '/' expr %prec MUL_OP {$$ = new MathExpr('/', $1, $3);}
          ;

bool_expr : expr BOOL_AND expr {$$ = new BoolExpr("&&", $1, $3);}
          | expr BOOL_OR expr {$$ = new BoolExpr("||", $1, $3);}
          | expr AND_KW expr {$$ = new BoolExpr("and", $1, $3);}
          | expr OR_KW expr {$$ = new BoolExpr("or", $1, $3);}
          ;

logical_expr : expr EQU expr {$$ = new LogicalExpr("==", $1, $3);}
             | expr NEQ expr {$$ = new LogicalExpr("!=", $1, $3);}
             | expr GTR expr {$$ = new LogicalExpr(">", $1, $3);}
             | expr LES expr {$$ = new LogicalExpr("<", $1, $3);}
             | expr GEQ expr {$$ = new LogicalExpr(">=", $1, $3);}
             | expr LEQ expr {$$ = new LogicalExpr("<=", $1, $3);}
             | expr IN_KW expr {$$ = new LogicalExpr("in", $1, $3);}
             | expr NOT_IN_KW expr {$$ = new LogicalExpr("not in", $1, $3);}
             ;

addr_of_expr : '&' expr %prec '&' {$$ = new AddrOf($2);}
             ;

deref_expr : '*' expr %prec '*' {$$ = new Deref($2);}
           ;

cast_expr : expr CAST_KW type_name {$$ = new CastExpr($3, $1);}
          ;

tuple_expr : '[' expr_list ']' {$$ = new TupleExpr($2);}
           ;

pre_expr : INC expr {$$ = new PreExpr("++", $2);}
         | DEC expr {$$ = new PreExpr("--", $2);}
         ;

function_call_expr : DECLARED_FUNC '(' args_list ')' {$$ = new FunctionCallExpr($1, $3);}
              | '(' expr ')' '(' args_list ')' {$$ = new FunctionCallExpr(new ParensExpr($2), $5);}
              ;

function_call_stmt : DECLARED_FUNC '(' args_list ')' {$$ = new FunctionCallStmt($1, $3);}
              | '(' expr ')' '(' args_list ')' {$$ = new FunctionCallStmt(new ParensExpr($2), $5);}
              ;

type_decl : type_alias {$$ = $1;}
          | struct_decl {$$ = $1;}
          ;

var_decl_init : var_decl '=' expr {$$ = new VarDeclInit($1, $3);}
              ;

array_literal : '{' expr_list '}' {$$ = new ArrayLiteral($2);}
              ;

var_decl : type_name IDENT {
                $$ = new VarDecl($1, $2);
                state->symtable->put($2->id, new Symbol(Var, { .var=$$ }));
            }
         ;

if_statement : IF_KW '(' expr ')' '{'
                {x::create_scope(&state->symtable);} statement_list '}' %prec IF_KW {
                    SymbolTable * table = x::pop_scope(&state->symtable);
                    $$ = new IfStmt($3, $7, table);
                }
             ;

if_else_statement : if_statement ELSE_KW '{' {x::create_scope(&state->symtable);} statement_list '}' {
                        SymbolTable * table = x::pop_scope(&state->symtable);
                        $$ = new IfElseStmt($1, $5, table);
                    }
                  ;

while_statement : WHILE_KW '(' expr ')' '{'
                    {x::create_scope(&state->symtable);} statement_list '}' %prec WHILE_KW {
                        SymbolTable * table = x::pop_scope(&state->symtable);
                        $$ = new WhileStmt($3, $7, table);
                    }
                ;

for_statement : FOR_KW '(' statement ';' {x::create_scope(&state->symtable);} expr ';' statement ')' '{' statement_list '}' {
                    SymbolTable * table = x::pop_scope(&state->symtable);
                    $$ = new ForStmt($3, $6, $8, $11, table);
                }
              ;

assignment : expr '=' expr {$$ = new Assignment($1, $3);}
           ;

var_decl_list : var_decl ';' {$$ = new VarDeclList({$1});}
              | var_decl_list var_decl ';' {$1->push_decl($2); $$ = $1;}
              ;

struct_decl : STRUCT_KW IDENT '{' {
                    state->symtable->put($2->id, new Symbol(Type, { .typ=nullptr }));
                    x::create_scope(&state->symtable);
                } var_decl_list '}' {
                    SymbolTable * table = x::pop_scope(&state->symtable);
                    $$ = new StructDecl($2, $5, table);
                    // We have to get the symbol we made in the first action and
                    // add the full type declaration
                    Symbol * sym = state->symtable->get($2->id);
                    sym->decl = (Decl) { .typ=$$ };
                }
            ;

args_list : args_list ',' expr {$1->push_expr($3); $$ = $1;}
          | expr {$$ = new ExprList({$1});}
          | /* empty */ {$$ = new ExprList({});}
          ;

params_list : params_list ',' var_decl {$1->push_param($3); $$ = $1;}
            | var_decl {$$ = new ParamsList({$1});}
            | /* empty */ {$$ = new ParamsList({});}
            ;

func_decl : type_name IDENT '(' params_list ')' '{' {
                state->symtable->put($2->id, new Symbol(Func, { .func=nullptr }));
                x::create_scope(&state->symtable);
                $4->add_to_scope(state->symtable);
            } statement_list '}' {
                SymbolTable * table = x::pop_scope(&state->symtable);
                $$ = new FuncDecl($2, $4, $1, $8, table);
                Symbol * sym = state->symtable->get($2->id);
                sym->decl = (Decl) { .func=$$ };
            }
          ;

return_statement : RETURN_KW expr {$$ = new ReturnStatement($2);}
                 ;

type_name : simple_type_name {$$ = $1;}
          | ptr_type_name {$$ = $1;}
          | mut_type_name {$$ = $1;}
          | tuple_type_name {$$ = $1;}
          | func_type_name {$$ = $1;}
          | static_arr_type_name {$$ = $1;}
          | parens_type_name {$$ = $1;}
          ;

func_type_name : '[' ']' FUNC_TYPE_OP type_name %prec FUNC_PREC {$$ = new FuncTypename(new TypenameList({}), $4);}
               | '[' type_list ']' FUNC_TYPE_OP type_name %prec FUNC_PREC {$$ = new FuncTypename($2, $5);}
               ;

static_arr_type_name : type_name '[' INT ']' {$$ = new StaticArrayTypename($1, $3);}
                     ;

parens_type_name : '(' type_name ')' {$$ = new ParensTypename($2);}
                 ;

simple_type_name : DECLARED_TYPE {$$ = $1;}
                 ;

ptr_type_name : type_name '*' {$$ = new PtrTypename($1);}
              ;

mut_type_name : MUT type_name {$$ = new MutTypename($2);}
              ;

tuple_type_name : '[' type_list ']' {$$ = new TupleTypename($2);}
                ;

type_list : type_name {$$ = new TypenameList({$1});}
          | type_list ',' type_name {$1->push_type($3); $$ = $1;}
          ;

type_alias : TYPE_ALIAS_KW IDENT '=' type_name {
                $$ = new TypeAlias($2, $4);
                state->symtable->put($2->id, new Symbol(Type, (Decl) { .typ=$$ }));
            }
           ;

num : INT {$$ = $1;}
    | FLOAT {$$ = $1;}
    | '-' INT {
            $$ = new IntLiteral(-$2->value);
            delete $2;
        }
    | '-' FLOAT {
            $$ = new FloatLiteral(-$2->value);
            delete $2;
        }
    ;
