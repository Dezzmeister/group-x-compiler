%code requires {
#include <stdio.h>

#include "parseutils.h"
#include "ast.h"
}

%code {
    #include "symtable.h"
    extern SymbolTable * symtable;
}

%union {
    ASTNode *tree;
    Expr *expr;
    Stmt *stmt;
    int itype;
    double dtype;
    char ctype;
    char * string;
}

%type <tree> program 
%type <expr> literal expr assignment
%type <stmt> print_stmt if_stmt while_stmt return_stmt stmt 
struct_decl func_decl var_decl param_list block statements
%type <itype>  typename 

%token <itype>  NUM_LITERAL;
%token <ctype>  CHAR_LITERAL;
%token <string> STR_LITERAL;
%token <itype>  BOOL_LITERAL;
%token <string> IDENTIFIER;

%token ASSIGN IF ELSE WHILE FOR BREAK RETURN PRINT STRUCT FUN
%token <itype> INT_TYPE FLOAT_TYPE CHAR_TYPE STRUCT_NAME

// To avoid dangling else, an else block is associated with 
// the innermost if block.
%precedence ELSE
%precedence ')'

%left <ctype> '-' '+'
%left <ctype> '*' '/'
%right <ctype> ASSIGN
%right <ctype> '^' 
%left UMINUS
%%

program : %empty {} 
        | statements { ASTNode::PrintASTNode($1);  }
        ;
    
statements : statements stmt {$$ = new Statements($1, $2);}
           | stmt
           ;

block  : '{' statements '}' { $$ =  $2;  }
 
stmt : expr {$$ = new ExprStmt($1);}
     | print_stmt
     | if_stmt 
     | while_stmt 
     | return_stmt
     | func_decl
     | var_decl
     | struct_decl
     ;

func_decl : typename IDENTIFIER '(' param_list ')' block 
{ $$ = new Function($1, $4, $6); } 
;
            
param_list : param_list ',' var_decl 
           | var_decl 
           | %empty { $$ = nullptr; } 
           ;

if_stmt : IF '(' expr ')' block { $$  = new If($3, $5); }
        | IF '(' expr ')' block ELSE block { $$ = new If($3, $5, $7);} 
        ;

while_stmt : WHILE '(' expr ')' block  { $$ = new While($3, $5);} 
           ;

return_stmt : RETURN expr {$$ = new Return($2); }
            ;

print_stmt  : PRINT '(' expr ')' '.' { $$ = new Print($3); }
            ;

expr  : expr '+' expr { $$ = new ArithExpr('+', $1, $3); }
      | expr '-' expr { $$ = new ArithExpr('-', $1, $3); }
      | expr '*' expr { $$ = new ArithExpr('*', $1, $3); }
      | expr '/' expr { $$ = new ArithExpr('/', $1, $3); }
      | expr '%' expr { $$ = new ArithExpr('%', $1, $3); }
      | '(' expr ')' { $$ = new Paren($2); }
      | '-' expr %prec '-' { $$ = new ArithExpr('-', $2->left, NULL); }
      | literal 
      | assignment
      | IDENTIFIER { $$ = new Id($1); }
      ;

assignment  : var_decl ASSIGN expr 
            { 
                VarDecl * vd = (VarDecl*) $1;
                $$ = new ArithExpr('=', vd->v, $3); 
            } 
            ;

struct_decl : STRUCT IDENTIFIER 
            { 
                SymbolTable::Push(new SymbolTable());
            } '{' struct_decl_list '}' 
            { 
                Symbol * s = new Symbol(SymbolTable::Pop());
                symtable->PutSymbol(s);
            }
            ;

struct_decl_list : struct_decl_list var_decl 
                 | var_decl 

var_decl    :  typename IDENTIFIER 
            { 
                $$ = new VarDecl($1, new Var($2)); 
                symtable->PutSymbol($2, $1);
            }
            ;

typename  : INT_TYPE
          | FLOAT_TYPE
          | CHAR_TYPE
          | STRUCT_NAME 
          
          
literal : NUM_LITERAL   {$$ = new Int($1); }
        | STR_LITERAL   {$$ = new String($1);}
        ;  
