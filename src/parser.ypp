%code requires {
#include <cstring>
#include "stdio.h" 
#include "parseutils.h"
#include "parser.h"
}


%code {
    #include "tree.h"
    #include "symtable.h"

    void print_helper(const char * pre, tree *root, bool is_left) {
        if (root) {
            printf("%s", pre);
            printf("%s", is_left ? "├──" : "└──");
            printf("%d\n", root->type);
            char* new_pre = new char[strlen(pre) + 5];
            strcpy(new_pre, pre);
            strcat(new_pre, is_left ? "│   " : "    ");
            print_helper(new_pre, root->left, true);
            print_helper(new_pre, root->right, false);
            delete[] new_pre;
        }
    }

    void print_tree(tree *root) {
        if (!root) {
            return;
        }
        print_helper("", root, false);
    }

    tree * mktree(int type, YYSTYPE val) {
        struct tree * tree = new struct tree; 
        tree->type = type; 
        tree->val = val;
        return tree;
    }

    tree * mktree(int type, tree *left = nullptr, tree *right = nullptr) {
        struct tree * tree = new struct tree; 
        tree->type = type;
        tree->left = left;
        tree->right = right;
        return tree;
    } 
}

%union {
    struct tree *tree;
    int itype;
    double dtype;
    char ctype;
    char * string;
}

%type <tree> program stmt_list stmt expr literal

%type <tree> if_stmt while_stmt print_stmt return_stmt 

%type <tree> assignment var_decl struct_decl

%type <itype> typename

%token <itype>  NUM;
%token <ctype>  CHAR;
%token <string> STR;
%token <itype>  BOOL;
%token <string> ID;

%token NEWLINE ASSIGN;

%token IF ELSE WHILE FOR BREAK

%token RETURN PRINT 

%token STRUCT

%left <ctype> '-' '+'
%left <ctype> '*' '/'
%right <ctype> ASSIGN
%right <ctype> '^' 

%token <itype> INT_TYPE FLOAT_TYPE CHAR_TYPE

%token STMT_LIST

%%

program : %empty {} 
        | stmt_list {print_tree($1);}
        ;
    
stmt_list : stmt_list stmt {$$ = mktree(STMT_LIST, $1, $2);}
          | stmt 
          ;

stmt : expr NEWLINE {$$ = $1;}
     | if_stmt 
     | while_stmt 
     | print_stmt
     | return_stmt
     | var_decl
     | struct_decl
     | NEWLINE { $$ = nullptr; }
     ;

if_stmt : IF '(' expr ')' stmt { $$ = mktree(IF, $3, $5);}
        ;

while_stmt : WHILE '(' expr ')' stmt { $$ = mktree(WHILE, $3, $5); }
           ;

print_stmt : PRINT '(' expr ')' { $$ = mktree(PRINT, $3);}

return_stmt : RETURN expr {$$ = mktree(RETURN, $2);}

expr  : expr '+' expr {$$ = mktree('+', $1, $3); }
      | expr '-' expr {$$ = mktree('-', $1, $3);}
      | expr '*' expr {$$ = mktree('*', $1, $3);} 
      | expr '/' expr {$$ = mktree('/', $1, $3);}
      | expr '^' expr {$$ = mktree('^', $1, $3);}
      | '(' expr ')'  {$$ = $2; } 
      | literal 
      | assignment
      ;

assignment  : var_decl ASSIGN expr {$$ = mktree(ASSIGN, $1, $3); }
            ;

struct_decl : STRUCT ID 
                { 
                    symrec *s = getsym($2); 
                    s->type = STRUCT;
                    $$ = mktree(STRUCT, YYSTYPE{.string = $2});
                }
            ;

var_decl : typename ID { $$ = mktree($1, YYSTYPE{.string = $2}); }
         ;

typename : INT_TYPE
          | FLOAT_TYPE
          | CHAR_TYPE
          | ID {
            struct symrec *s = getsym($1);
            if (!s || s->type != STRUCT) {
                char s[50];
                sprintf(s, "Undeclared struct %s", $1);
                x::syntax_error(s);
            }
            else {
                $$ = s->type;
            }
            }

literal : NUM  {$$ = mktree(NUM, YYSTYPE{.itype = $1}) ;  }
        | CHAR {$$ = mktree(CHAR, YYSTYPE{.ctype = $1}); } 
        | STR  {$$ = mktree(STR, YYSTYPE{.string = $1}); }
        | BOOL {$$ = mktree(NUM, YYSTYPE{.itype = $1});  }
        ;  
