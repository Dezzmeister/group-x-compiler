%code requires {
#include <stdio.h>
#include "parseutils.h"
#include "parser.h"
#include "ast.h"

extern void yyerror(const char * const error);
}

%union {
    int int_val;
    float float_val;
    char * c_str;

    ASTNode * ast;
    MathExpr * math_expr;
    NumLiteral * num_literal;
    IntLiteral * int_literal;
    FloatLiteral * float_literal;
    Ident * ident;
    Typename * type_name;
    PtrTypename * ptr_type_name;
    MutTypename * mut_type_name;
    TupleTypename * tuple_type_name;
    TypenameList * type_list;
    VarDeclList * var_decl_list;
    FuncTypename * func_type_name;
    TypeAlias * type_alias;
    TypeDecl * type_decl;
    StructDecl * struct_decl;
    VarDecl * var_decl;
}

%token <int_literal> INT
%token <float_literal> FLOAT
%token <ident> INT_TYPE FLOAT_TYPE CHAR_TYPE IDENT
%token FUNC_TYPE_OP NEWLINE

%right '='
%right MUT TYPE_ALIAS_KW STRUCT_KW
%precedence FUNC_PREC
%left '*'
%right '('
%left ')'

%type <num_literal> num
%type <math_expr> math_expr
%type <type_name> type_name
%type <ident> simple_type_name
%type <ptr_type_name> ptr_type_name
%type <mut_type_name> mut_type_name
%type <tuple_type_name> tuple_type_name
%type <func_type_name> func_type_name
%type <type_list> type_list
%type <var_decl_list> var_decl_list
%type <struct_decl> struct_decl
%type <type_alias> type_alias
%type <type_decl> type_decl
%type <var_decl> var_decl

%%

statement : math_expr ';' {x::top = $1; YYACCEPT;}
          | type_decl ';' {x::top = $1; YYACCEPT;}
          | var_decl ';' {x::top = $1; YYACCEPT;}
          ;

math_expr : math_expr '+' num {x::parse_math_op_expr(&$$, $1, '+', $3);}
          | math_expr '-' num {x::parse_math_op_expr(&$$, $1, '-', $3);}
          | math_expr '*' num {x::parse_math_op_expr(&$$, $1, '*', $3);}
          | math_expr '/' num {x::parse_math_op_expr(&$$, $1, '/', $3);}
          | num {$$ = (MathExpr *) $1;}
          ;

type_decl : type_alias {$$ = $1;}
          | struct_decl {$$ = $1;}
          ;

var_decl : type_name IDENT {$$ = new VarDecl($1, $2);}
         ;

var_decl_list : var_decl ';' {$$ = new VarDeclList({$1});}
              | var_decl_list var_decl ';' {$1->push_decl($2); $$ = $1;}
              ;

struct_decl : STRUCT_KW IDENT '{' var_decl_list '}' {$$ = new StructDecl($2, $4);}
            ;

type_name : simple_type_name {$$ = $1;}
          | ptr_type_name {$$ = $1;}
          | mut_type_name {$$ = $1;}
          | tuple_type_name {$$ = $1;}
          | func_type_name {$$ = $1;}
          | '(' type_name ')' {$$ = new ParensTypename($2);}
          ;

func_type_name : '[' type_list ']' FUNC_TYPE_OP type_name %prec FUNC_PREC {$$ = new FuncTypename($2, $5);}
               ;

simple_type_name : INT_TYPE {$$ = $1;}
                 | FLOAT_TYPE {$$ = $1;}
                 | CHAR_TYPE {$$ = $1;}
                 | IDENT {$$ = $1;}
                 ;

ptr_type_name : type_name '*' {$$ = new PtrTypename($1);}
              ;

mut_type_name : MUT type_name {$$ = new MutTypename($2);}
              ;

tuple_type_name : '[' type_list ']' {$$ = new TupleTypename($2);}
                ;

type_list : type_name {$$ = new TypenameList({$1});}
          | type_list ',' type_name {$1->push_type($3); $$ = $1;}
          ;

type_alias : TYPE_ALIAS_KW IDENT '=' type_name {$$ = new TypeAlias($2, $4);}
           ;

num : INT {$$ = $1;}
    | FLOAT {$$ = $1;}
    | '-' INT {
            $$ = new IntLiteral(-$2->value);
            delete $2;
        }
    | '-' FLOAT {
            $$ = new FloatLiteral(-$2->value);
            delete $2;
        }
    ;
