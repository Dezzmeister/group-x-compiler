// %define parse.trace /* Enable tracing */
// %verbose /* Output parser.output file */

%code requires {
#include <cstring>
#include "stdio.h" 
#include "parseutils.h"
#include "parser.h"
#include "symtable.h"
#include "tree.h"
}

%code {
    void print_helper(const char * pre, tree *root, bool is_left) {
        if (root) {
            printf("%s", pre);
            printf("%s", is_left ? "├──" : "└──");
            printf("%d\n", root->type);
            char* new_pre = new char[strlen(pre) + 5];
            strcpy(new_pre, pre);
            strcat(new_pre, is_left ? "│   " : "    ");
            print_helper(new_pre, root->left, true);
            print_helper(new_pre, root->right, false);
            delete[] new_pre;
        }
    }

    void print_tree(tree *root) {
        if (!root) {
            printf("root is empty\n");
        }
        print_helper("", root, false);
    }

    tree * mktree(int type, tree *left = nullptr, tree *right = nullptr) {
        struct tree * tree = new struct tree; 
        tree->type = type;
        tree->left = left;
        tree->right = right;
        return tree;
    } 
}

%union {
    struct tree *tree;
    int itype;
    double dtype;
    char ctype;
    char * string;
}

%type <tree> program stmt_list stmt expr literal

%token <itype>  NUM;
%token <ctype>  CHAR;
%token <string> STR;
%token <itype>  BOOL;
%token <string> ID;

%token NEWLINE ASSIGN;

%token IF ELSE WHILE FOR BREAK

%token RETURN PRINT 

%left <ctype> '-' '+'
%left <ctype> '*' '/'
%right <ctype> ASSIGN
%right <ctype> '^' 

%%

program : { } 
        | program stmt_list { print_tree($2); }
        ;
    
stmt_list : %empty
          | stmt_list stmt { if ($2) {$$ = $2;} }
          ;

stmt : expr NEWLINE {$$ = $1; }
     | NEWLINE { $$ = nullptr; }
     ;
    

expr  : expr '+' expr {$$ = mktree('+', $1, $3); }
      | expr '-' expr {$$ = mktree('-', $1, $3);}
      | expr '*' expr {$$ = mktree('*', $1, $3);} 
      | expr '/' expr {$$ = mktree('/', $1, $3);}
      | expr '^' expr {$$ = mktree('^', $1, $3);}
      | '(' expr ')'  {$$ = $2; } 
      | literal
      ;

literal : NUM  {$$ = mktree(NUM); }
        | CHAR {$$ = mktree(CHAR);} 
        | STR  {$$ = mktree(STR); }
        | BOOL {$$ = mktree(BOOL);}
        ;
